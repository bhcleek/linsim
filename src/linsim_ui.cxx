// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include "linsim_ui.h"
#include <string>
#include "sound.h"
#include "sim_vals.h"
#include "sim.h"
static std::string fname_in; 
static std::string fname_out; 
_vals sim_vals;
static SIM sim_test; 

Fl_Double_Window *linsim_window=(Fl_Double_Window *)0;

static void cb_E(Fl_Menu_*, void*) {
  linsim_window->hide();
}

Fl_Menu_Item menu_[] = {
 {"&File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"E&xit", 0,  (Fl_Callback*)cb_E, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Output *txt_input_file=(Fl_Output *)0;

Fl_Output *txt_output_file=(Fl_Output *)0;

Fl_Check_Button *p0_on=(Fl_Check_Button *)0;

static void cb_p0_on(Fl_Check_Button* o, void*) {
  sim_vals.p0.active = o->value();
}

Fl_Float_Input *inp_spread0=(Fl_Float_Input *)0;

static void cb_inp_spread0(Fl_Float_Input* o, void*) {
  sim_vals.p0.spread = atof(o->value());
}

Fl_Float_Input *inp_offset0=(Fl_Float_Input *)0;

static void cb_inp_offset0(Fl_Float_Input* o, void*) {
  sim_vals.p0.offset = atof(o->value());
}

Fl_Check_Button *p1_on=(Fl_Check_Button *)0;

static void cb_p1_on(Fl_Check_Button* o, void*) {
  sim_vals.p1.active = o->value();
}

Fl_Float_Input *inp_delay1=(Fl_Float_Input *)0;

static void cb_inp_delay1(Fl_Float_Input* o, void*) {
  sim_vals.d.delay1 = atof(o->value());
}

Fl_Float_Input *inp_spread1=(Fl_Float_Input *)0;

static void cb_inp_spread1(Fl_Float_Input* o, void*) {
  sim_vals.p1.spread = atof(o->value());
}

Fl_Float_Input *inp_offset1=(Fl_Float_Input *)0;

static void cb_inp_offset1(Fl_Float_Input* o, void*) {
  sim_vals.p1.offset = atof(o->value());
}

Fl_Check_Button *p2_on=(Fl_Check_Button *)0;

static void cb_p2_on(Fl_Check_Button* o, void*) {
  sim_vals.p2.active = o->value();
}

Fl_Float_Input *inp_delay2=(Fl_Float_Input *)0;

static void cb_inp_delay2(Fl_Float_Input* o, void*) {
  sim_vals.d.delay2 = atof(o->value());
}

Fl_Float_Input *inp_spread2=(Fl_Float_Input *)0;

static void cb_inp_spread2(Fl_Float_Input* o, void*) {
  sim_vals.p2.spread = atof(o->value());
}

Fl_Float_Input *inp_offset2=(Fl_Float_Input *)0;

static void cb_inp_offset2(Fl_Float_Input* o, void*) {
  sim_vals.p1.offset = atof(o->value());
}

Fl_Check_Button *inp_AWGN_on=(Fl_Check_Button *)0;

static void cb_inp_AWGN_on(Fl_Check_Button* o, void*) {
  sim_vals.AWGN_on = o->value();
}

Fl_Float_Input *inp_AWGN_rms=(Fl_Float_Input *)0;

static void cb_inp_AWGN_rms(Fl_Float_Input* o, void*) {
  sim_vals.snrdb = atof(o->value());
}

Fl_Progress *progress=(Fl_Progress *)0;

Fl_Button *btn_test=(Fl_Button *)0;

static void cb_btn_test(Fl_Button*, void*) {
  double buffer[MAX_BUF_SIZE];
sim_test.AWGN(sim_vals.AWGN_on);
sim_test.SetsnrValue(sim_vals.snrdb);
sim_test.init(8000.0, sim_vals.p0, sim_vals.p1, sim_vals.p2, sim_vals.d);
if (fname_in.empty() || fname_out.empty()) return;
sim_test.sound_in.open(fname_in, SoundFile::READ);
size_t fsize = 0, r = 0, partial = 0;
sim_test.signal_rms = 0.0;
while ((r = sim_test.sound_in.read(buffer, MAX_BUF_SIZE)) > 0) {
  sim_test.measure_rms(buffer, MAX_BUF_SIZE);
  fsize += r;
}
sim_test.sound_in.rewind();
sim_test.sound_out.open(fname_out, SoundFile::WRITE);
progress->value(0);
progress->minimum(0);
progress->maximum(fsize * 1.0);
while ((r = sim_test.sound_in.read(buffer, MAX_BUF_SIZE)) > 0) {
  partial += r;
  if ((partial / r) % 4 == 0) {
    progress->value(partial*1.0);
    progress->redraw();
    Fl::flush();
  }
  sim_test.Process(buffer, r);
  sim_test.sound_out.write(buffer, r);
}
progress->value(fsize * 1.0);
sim_test.sound_in.close();
sim_test.sound_out.close();
progress->value(0);
progress->redraw();
}

Fl_Button *btn_select_input=(Fl_Button *)0;

static void cb_btn_select_input(Fl_Button*, void*) {
  fname_in = file_name("input.wav");
txt_input_file->value(fname_in.c_str());
}

Fl_Button *btn_select_output=(Fl_Button *)0;

static void cb_btn_select_output(Fl_Button*, void*) {
  fname_out = file_name("output.wav");
txt_output_file->value(fname_out.c_str());
}

Fl_Double_Window* make_linsim_window() {
  fname_in.clear();
  fname_out.clear();
  { linsim_window = new Fl_Double_Window(340, 305, "linsim v1.0.0");
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 453, 20);
      o->menu(menu_);
    } // Fl_Menu_Bar* o
    { txt_input_file = new Fl_Output(65, 25, 270, 24);
      txt_input_file->textsize(12);
    } // Fl_Output* txt_input_file
    { txt_output_file = new Fl_Output(65, 55, 270, 24);
      txt_output_file->textsize(12);
    } // Fl_Output* txt_output_file
    { Fl_Group* o = new Fl_Group(8, 83, 328, 51);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Check_Button* o = p0_on = new Fl_Check_Button(22, 99, 70, 19, "Path 1");
        p0_on->down_box(FL_DOWN_BOX);
        p0_on->callback((Fl_Callback*)cb_p0_on);
        o->value(sim_vals.p0.active);
      } // Fl_Check_Button* p0_on
      { Fl_Float_Input* o = inp_spread0 = new Fl_Float_Input(180, 105, 70, 24, "Spread");
        inp_spread0->tooltip("spread in Hz (1 sigma)");
        inp_spread0->type(1);
        inp_spread0->callback((Fl_Callback*)cb_inp_spread0);
        inp_spread0->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.p0.spread);o->value(val);
      } // Fl_Float_Input* inp_spread0
      { Fl_Float_Input* o = inp_offset0 = new Fl_Float_Input(255, 105, 70, 24, "Offset");
        inp_offset0->tooltip("frequency offset in Hz");
        inp_offset0->type(1);
        inp_offset0->callback((Fl_Callback*)cb_inp_offset0);
        inp_offset0->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.p0.offset);o->value(val);
      } // Fl_Float_Input* inp_offset0
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(9, 139, 328, 51);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Check_Button* o = p1_on = new Fl_Check_Button(23, 155, 70, 19, "Path 2");
        p1_on->down_box(FL_DOWN_BOX);
        p1_on->callback((Fl_Callback*)cb_p1_on);
        o->value(sim_vals.p1.active);
      } // Fl_Check_Button* p1_on
      { Fl_Float_Input* o = inp_delay1 = new Fl_Float_Input(101, 158, 70, 25, "Delay");
        inp_delay1->tooltip("delay in milliseconds");
        inp_delay1->type(1);
        inp_delay1->callback((Fl_Callback*)cb_inp_delay1);
        inp_delay1->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.d.delay1);o->value(val);
      } // Fl_Float_Input* inp_delay1
      { Fl_Float_Input* o = inp_spread1 = new Fl_Float_Input(180, 158, 70, 24, "Spread");
        inp_spread1->tooltip("spread in Hz (1 sigma)");
        inp_spread1->type(1);
        inp_spread1->callback((Fl_Callback*)cb_inp_spread1);
        inp_spread1->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.p1.spread);o->value(val);
      } // Fl_Float_Input* inp_spread1
      { Fl_Float_Input* o = inp_offset1 = new Fl_Float_Input(255, 158, 70, 24, "Offset");
        inp_offset1->tooltip("frequency offset in Hz");
        inp_offset1->type(1);
        inp_offset1->callback((Fl_Callback*)cb_inp_offset1);
        inp_offset1->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.p1.offset);o->value(val);
      } // Fl_Float_Input* inp_offset1
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(9, 195, 328, 51);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Check_Button* o = p2_on = new Fl_Check_Button(23, 211, 70, 19, "Path 3");
        p2_on->down_box(FL_DOWN_BOX);
        p2_on->callback((Fl_Callback*)cb_p2_on);
        o->value(sim_vals.p2.active);
      } // Fl_Check_Button* p2_on
      { Fl_Float_Input* o = inp_delay2 = new Fl_Float_Input(101, 215, 70, 25, "Delay");
        inp_delay2->tooltip("delay in milliseconds");
        inp_delay2->type(1);
        inp_delay2->callback((Fl_Callback*)cb_inp_delay2);
        inp_delay2->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.d.delay2);o->value(val);
      } // Fl_Float_Input* inp_delay2
      { Fl_Float_Input* o = inp_spread2 = new Fl_Float_Input(180, 215, 70, 24, "Spread");
        inp_spread2->tooltip("spread in Hz (1 sigma)");
        inp_spread2->type(1);
        inp_spread2->callback((Fl_Callback*)cb_inp_spread2);
        inp_spread2->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.p2.spread);o->value(val);
      } // Fl_Float_Input* inp_spread2
      { Fl_Float_Input* o = inp_offset2 = new Fl_Float_Input(255, 215, 70, 24, "Offset");
        inp_offset2->tooltip("frequency offset in Hz");
        inp_offset2->type(1);
        inp_offset2->callback((Fl_Callback*)cb_inp_offset2);
        inp_offset2->align(Fl_Align(FL_ALIGN_TOP));
        char val[20]; snprintf(val, sizeof(val), "%4.2f", sim_vals.p2.offset);o->value(val);
      } // Fl_Float_Input* inp_offset2
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(10, 250, 166, 51);
      o->box(FL_ENGRAVED_FRAME);
      { Fl_Check_Button* o = inp_AWGN_on = new Fl_Check_Button(24, 266, 70, 19, "AWGN");
        inp_AWGN_on->tooltip("Gaussian noise on/off");
        inp_AWGN_on->down_box(FL_DOWN_BOX);
        inp_AWGN_on->callback((Fl_Callback*)cb_inp_AWGN_on);
        o->value(sim_vals.AWGN_on);
      } // Fl_Check_Button* inp_AWGN_on
      { Fl_Float_Input* o = inp_AWGN_rms = new Fl_Float_Input(101, 270, 70, 25, "S/N");
        inp_AWGN_rms->tooltip("s/n in dB");
        inp_AWGN_rms->type(1);
        inp_AWGN_rms->callback((Fl_Callback*)cb_inp_AWGN_rms);
        inp_AWGN_rms->align(Fl_Align(FL_ALIGN_TOP));
        char val[20];
        snprintf(val, sizeof(val), "%4.1f", sim_vals.snrdb);
        o->value(val);
      } // Fl_Float_Input* inp_AWGN_rms
      o->end();
    } // Fl_Group* o
    { Fl_Progress* o = progress = new Fl_Progress(179, 252, 153, 21);
      o->value(0);
      o->minimum(0); o->maximum(1);
      o->selection_color(FL_DARK_BLUE);
    } // Fl_Progress* progress
    { btn_test = new Fl_Button(261, 277, 70, 24, "Run Test");
      btn_test->callback((Fl_Callback*)cb_btn_test);
    } // Fl_Button* btn_test
    { btn_select_input = new Fl_Button(3, 25, 60, 24, "Input");
      btn_select_input->callback((Fl_Callback*)cb_btn_select_input);
    } // Fl_Button* btn_select_input
    { btn_select_output = new Fl_Button(4, 55, 60, 24, "Output");
      btn_select_output->callback((Fl_Callback*)cb_btn_select_output);
    } // Fl_Button* btn_select_output
    linsim_window->end();
  } // Fl_Double_Window* linsim_window
  return linsim_window;
}
